#!/usr/bin/python
# Copyright 2016 AT&T Corp
# All Rights Reserved.
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

import logging
import re
import subprocess
import sys
import time
import yaml


class RbacWrapper:

    def __init__(self):
        logging.info('Initializing')
        sleep_time = 120
        logging.info('Waiting for contrail process:%s', str(sleep_time))
        time.sleep(sleep_time)
        print "RBAC Wrapper running..."
        self.__rbac_parser()


    def __rbac_parser(self):
        #   -- Main parser function --
        try:
            io_path = '/var/lib/fuel/rbac_wrapper/rbac_settings.yaml'
            content = open(io_path, "r")
            all_roles = 8
            admin_access = 'CRUD'
            # Port will dynamically get-fetched from manifest
            port = '<%= scope.lookupvar('contrail::api_server_port') %>'
            confirm =  'y'
            contrail_usr = 'admin'
            contrail_pwd = 'admin'
            script_path = '/var/lib/fuel/rbac_wrapper/rbac_cmd.sh'
            if not content.read():
                logging.error("Empty file found")
                sys.exit()
            else:
                logging.info("Not empty file")

            policies = yaml.load_all(open(io_path, "r"))
            #since file content gets flushed
            for policy in policies:
                for actions, roles in policy.items():
                    if len(roles) > 0:
                        logging.info('Action:%s --> roles:%s', actions, roles)
                        access = self.__access_control(actions)
                        permissions = ''

                        logging.info('No. is %s & Roles are: %s', len(roles), roles)
                        if len(roles) >= all_roles:
                            roles = ['admin_contrail', 'admin', '*']

                        for role in roles:
                            logging.debug('Role %s', role)
                            if role in ['admin', 'admin_contrail']:
                                access_assign = admin_access
                            else:
                                access_assign = access

                            permissions = (permissions
                                           + str(role) + ':'
                                           + access_assign + ',')

                            logging.debug('Permissions:%s', permissions)

                        if (len(permissions) > 0):
                            permissions = permissions.rstrip(",")
                            logging.info('Complete Permissions:%s', permissions)

                        #   The commands that have to be run are called
                        #   with variables
                        first = subprocess.Popen(['echo', confirm],
                                                 stdout=subprocess.PIPE)
                        logging.debug('First cmd: %s', str(first))
                        second = subprocess.check_output(
                            ['/bin/bash',
                             script_path, actions,
                             permissions, port,
                             contrail_usr, contrail_pwd], stdin=first.stdout)
                        logging.debug('Second cmd: %s', str(second))
                    else:
                        logging.warning('Roles are not present for action:%s',
                                        actions)

        # --Exceptions being handled--
        except IOError as e:
            logging.error("Exception: File does not exist: %s", str(e))
        except subprocess.CalledProcessError as e:
            logging.error("Exception: Bad subprocess command: %s", str(e))
        except Exception as e:
            logging.error("Exception: %s", str(e))

    def __access_control(self, actions):
        #   --- Access being set for admin/admin_contrail and other roles---
        access = 'R'

        if re.match('show|list|get|read', actions):
            access = 'R'
            logging.debug('access: %s', access)

        if re.match('create|add|post', actions):
            access = 'CR'
            logging.debug('access: %s', access)

        if re.match('update|put', actions):
            access = 'UR'
            logging.debug('access: %s', access)

        if re.match('delete', actions):
            access = 'RD'
            logging.debug('access: %s', access)

        return access


def main():

    logging.basicConfig(level=logging.DEBUG,
                        format='%(asctime)s %(levelname)s %(message)s',
                        filename='/var/lib/fuel/rbac_wrapper/rbac_wrapper.log')
    logging.info('-------Rbac Wrapper execution Started-------')
    RbacWrapper()
    logging.info('-------Rbac Wrapper execution Completed------')
    logging.info('------------------------- ********* ----------------------')
    print "RBAC Wrapper execution completed"
# end main

if __name__ == "__main__":
    main()
