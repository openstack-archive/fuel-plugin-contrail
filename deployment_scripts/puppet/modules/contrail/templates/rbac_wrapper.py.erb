#!/usr/bin/python
# Copyright 2016 AT&T Corp
# All Rights Reserved.
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

import logging
import re
import subprocess
import sys
import time
import yaml
import requests


class RbacWrapper:

    def __init__(self):
        logging.info('Initializing')
        self.check_contrail_api()
        print "RBAC Wrapper running..."
        self.__rbac_parser()

    def __rbac_parser(self):
        #   -- Main parser function --
        try:
            io_path = '/var/lib/fuel/rbac_wrapper/rbac_settings.yaml'
            content = open(io_path, "r")
            # Port will dynamically get-fetched from manifest
            port = '<%= scope.lookupvar('contrail::api_server_port') %>'
            port = '9100'
            confirm = 'y'
            contrail_usr = '<%= scope.lookupvar('contrail::rbac_settings::user_name') %>'
            contrail_pwd = '<%= scope.lookupvar('contrail::rbac_settings::user_password') %>'
            script_path = '/var/lib/fuel/rbac_wrapper/rbac_cmd.sh'
            if not content.read():
                logging.error("Empty file found")
                sys.exit()
            else:
                logging.info("Not empty file")

            policies = yaml.load_all(open(io_path, "r"))
            # since file content gets flushed
            for policy in policies:
                for object, permissions in policy.items():
                    logging.info('Object:%s --> permissions:%s', object, permissions)

                    #   The commands that have to be run are called
                    #   with variables
                    first = subprocess.Popen(['echo', confirm],
                                             stdout=subprocess.PIPE)
                    logging.debug('First cmd: %s', str(first))

                    second = subprocess.check_output(['/bin/bash', script_path,
                                                      object, permissions,
                                                      port, contrail_usr,
                                                      contrail_pwd],
                                                     stdin=first.stdout)

                    logging.debug('Second cmd: %s', str(second))

        # --Exceptions being handled--
        except IOError as e:
            logging.error("Exception: File does not exist: %s", str(e))
        except subprocess.CalledProcessError as e:
            logging.error("Exception: Bad subprocess command: %s", str(e))
        except Exception as e:
            logging.error("Exception: %s", str(e))

    def __access_control(self, actions):
        #   --- Access being set for admin/admin_contrail and other roles---
        access = 'R'

        if re.match('show|list|get|read', actions):
            access = 'R'
            logging.debug('access: %s', access)

        if re.match('create|add|post', actions):
            access = 'CR'
            logging.debug('access: %s', access)

        if re.match('update|put', actions):
            access = 'UR'
            logging.debug('access: %s', access)

        if re.match('delete', actions):
            access = 'RD'
            logging.debug('access: %s', access)

        return access

    def check_if_operational(self):
        try:
            req = requests.get('http://127.0.0.1:9100')
            if req.ok:
                return req.ok
        except requests.exceptions.ConnectionError:
            print 'Connection Error, retrying'

    def check_contrail_api(self):
        try_amount = 10
        try_real = 0
        while not self.check_if_operational():
            print 'Connection Error, retrying'
            try_real +=1
            time.sleep(5)
            if try_real > try_amount:
                print 'Time exceeded, check contrail-api'
                exit(1)


def main():

    logging.basicConfig(level=logging.DEBUG,
                        format='%(asctime)s %(levelname)s %(message)s',
                        filename='/var/lib/fuel/rbac_wrapper/rbac_wrapper.log')
    logging.info('-------Rbac Wrapper execution Started-------')
    RbacWrapper()
    logging.info('-------Rbac Wrapper execution Completed------')
    logging.info('------------------------- ********* ----------------------')
    print "RBAC Wrapper execution completed"
# end main

if __name__ == "__main__":
    main()

