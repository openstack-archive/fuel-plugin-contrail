#!/usr/bin/env python

import argparse
import atexit
import errno
import os
import sys
import time
import yaml
import subprocess

from pyVmomi import vmodl
from pyVmomi import vim
from pyVim import connect


class Generic(object):
    def __init__(self):
        self._environment = None
        self._data = None
        self._fuel_attributes = None
        self._plugin_data = None
        self._options = None
        self.object = None

    def debug(self, *args):
        if self.options.verbose:
            sys.stderr.write(' '.join(args) + "\n")

    @property
    def options(self):
        if self._options:
            return self._options

        parser = argparse.ArgumentParser()

        parser.add_argument('-s', '--host',
                            required=True,
                            action='store',
                            help='Remote host to connect to')

        parser.add_argument('-u', '--user',
                            required=True,
                            action='store',
                            help='User name to use when connecting to host')

        parser.add_argument('-p', '--password',
                            required=False,
                            action='store',
                            help='Password to use when connecting to host')

        parser.add_argument('-i', '--ip',
                            required=False,
                            action='store',
                            nargs='+',
                            help='IP address of the VM to search for')

        parser.add_argument('-y', '--yaml',
                            required=False,
                            action='store_true',
                            default=False,
                            help='YAML format output')

        parser.add_argument('-d', '--dvs',
                            required=False,
                            action='store_true',
                            help='Get DVS mappings YAML-format output')

        parser.add_argument('-v', '--verbose',
                            required=False,
                            action='store_true',
                            help='Verbose output for debugging')

        parser.set_defaults(yaml=False)

        self._options = parser.parse_args()
        return self._options

    @staticmethod
    def hiera_lookup(hiera_key, lookup_type='priority'):
        """
        Extract the data from Hiera using the Ruby call.
        Yes, it looks funny but other ways to do it are worse.
        I have to use the Ruby implementation of hiera here
        with the Puppet config file.
        :param lookup_type: Which lookup type should be used?
        # priority, hash, array
        :type lookup_type: str
        :param hiera_key: the key to search
        :type hiera_key: str
        :return: hiera data
        :rtype: None, str, list, dict
        """
        hiera_lookup = '''
        ruby -r hiera -r yaml -e '
        hiera = Hiera.new(:config => "/etc/puppet/hiera.yaml");
        data = hiera.lookup("{hiera_key}", nil, {{}}, nil, :{lookup_type});
        puts YAML.dump data;
        '
        '''
        try:
            command = hiera_lookup.format(
                hiera_key=hiera_key,
                lookup_type=lookup_type,
            )
            response = subprocess.Popen(
                command,
                shell=True,
                stdout=subprocess.PIPE,
            )
            yaml_data = yaml.load(response.stdout.read())
            return yaml_data
        except subprocess.CalledProcessError as exception:
            logging.warn('Could not get Hiera data: {} Code: {} Output: {}'.format(
                hiera_key,
                exception.returncode,
                exception.output,
            ))
            return None

    def main(self):
        if self.options.dvs:
            self.object = Dvs(self)
        else:
            self.object = VrouterMap(self)
        self.object.main()


class VrouterMap(object):
    def __init__(self, generic):
        self.generic = generic
        self._search_index = None
        self._data = None
        self.service_instance = None

    @property
    def search_index(self):
        if self._search_index:
            return self._search_index

        # form a connection...
        si = connect.SmartConnect(
            host=self.generic.options.host,
            user=self.generic.options.user,
            pwd=self.generic.options.password,
            port=443,
        )
        atexit.register(connect.Disconnect, si)

        self.service_instance = si
        self._search_index = si.content.searchIndex
        return self._search_index

    def esxi_hostname_get(self, vrouter_private_ip=None):
        try:
            esxi_object = self.search_index.FindByIp(None, vrouter_private_ip, True)
            if not esxi_object:
                return None
            esxi_host_name = esxi_object.runtime.host.name
            if not esxi_host_name:
                return None
            return esxi_host_name
        except TypeError:
            return None

    def retrieve_esxi_hostname(self, vrouter_private_ip=None):
        for retry in xrange(10):
            esxi_hostname = self.esxi_hostname_get(vrouter_private_ip)
            esxi_ip = self.get_host_ip_by_name(esxi_hostname)
            if esxi_hostname is not None:
                return esxi_ip
            self.generic.debug("Can not get ip will try one more time")
            time.sleep(5)
        self.generic.debug("Could not get association for that ip: ", vrouter_private_ip)
        return None

    def get_host_ip_by_name(self, name):
        host_obj = self.get_obj([vim.HostSystem], name)
        host_ip = host_obj.config.vmotion.ipConfig.ipAddress
        return host_ip

    def get_obj(self, vimtype, name):
        """
        Get the vsphere object associated with a given text name
        """
        obj = None
        content = self.service_instance.RetrieveContent()
        container = content.viewManager.CreateContainerView(content.rootFolder, vimtype, True)
        for c in container.view:
            if c.name == name:
                obj = c
                break
        return obj

    @property
    def data(self):
        """
        :return: Mappings of the vcenter ips to the esxi ips
        :rtype: dict
        """
        if self._data:
            return self._data
        self._data = {}
        for vrouter_ip in self.generic.options.ip:
            esxi_ip = self.retrieve_esxi_hostname(vrouter_ip)
            if esxi_ip is None:
                continue
            self._data[vrouter_ip] = esxi_ip
        return self._data

    def output_yaml(self):
        print(yaml.dump(
            {'esxi_mapping': self.data},
            explicit_start=True,
            default_flow_style=False,
        ))

    def output_text(self):
        map_mask = '{vcenter}:{vrouter}'
        for vrouter_ip in self.data:
            print(map_mask.format(vcenter=self.data[vrouter_ip], vrouter=vrouter_ip))

    def main(self):
        if self.generic.options.yaml:
            self.output_yaml()
        else:
            self.output_text()


class Dvs(object):
    def __init__(self, generic):
        self.generic = generic
        self._connect_to_vcenter = None
        self._hosts_port_groups = None
        self._content = None
        self._vms = None
        self.hosts = self.get_hosts

    @property
    def connect_to_vcenter(self):
        """
        :return:
        """
        if self._connect_to_vcenter:
            return self._connect_to_vcenter

        service_instance = connect.SmartConnect(
            host=self.generic.options.host,
            user=self.generic.options.user,
            pwd=self.generic.options.password,
            port=443,
        )

        atexit.register(connect.Disconnect, service_instance)

        self._connect_to_vcenter = service_instance
        return self._connect_to_vcenter

    @property
    def get_hosts(self):
        """
        :return: List of found ESXi hosts
        :rtype: list
        """
        host_view = self.content.viewManager.CreateContainerView(
            self.content.rootFolder,
            [vim.HostSystem],
            True,
        )
        hosts = [host for host in host_view.view]
        host_view.Destroy()
        return hosts

    def get_vm_nics(self, vm):
        """
        Receive the list of network interfaces for this ESXi vm
        :param vm:
        :return:
        :rtype: list
        """
        nic_list = []
        for dev in vm.config.hardware.device:
            if isinstance(dev, vim.vm.device.VirtualEthernetCard):
                dev_backing = dev.backing
                vlan_id = None
                v_switch = None
                if hasattr(dev_backing, 'port'):
                    port_group_key = dev_backing.port.portgroupKey
                    dvs_uuid = dev_backing.port.switchUuid
                    try:
                        dvs = self.content.dvSwitchManager.QueryDvsByUuid(dvs_uuid)
                    except StandardError:
                        port_group = "** Error: DVS not found **"
                        vlan_id = "NA"
                        v_switch = "NA"
                    else:
                        pg_obj = dvs.LookupDvPortGroup(port_group_key)
                        port_group = pg_obj.config.name
                        v_switch = str(dvs.name)
                else:
                    port_group = dev_backing.network.name
                    vm_host = vm.runtime.host
                    # global variable hosts is a list, not a dict
                    host_pos = self.hosts.index(vm_host)
                    view_host = self.hosts[host_pos]
                    # global variable host_pg_dict stores portgroups per host
                    pgs = self.hosts_port_groups[view_host]
                    for pg in pgs:
                        if port_group in pg.key:
                            vlan_id = str(pg.spec.vlanId)
                            v_switch = str(pg.spec.vswitchName)
                if port_group is None:
                    port_group = 'NA'
                if vlan_id is None:
                    vlan_id = 'NA'
                if v_switch is None:
                    v_switch = 'NA'
                self.generic.debug('\t' + dev.deviceInfo.label + '->' + dev.macAddress +
                                   ' @ ' + v_switch + '->' + port_group + ' (vlan ' + vlan_id + ')')
                nic = {
                    'niclabel': dev.deviceInfo.label,
                    'macAddress': dev.macAddress,
                    'vSwitch': v_switch,
                    'portGroup': port_group,
                    'vlanId': vlan_id,
                }
                nic_list.append(nic)
        return nic_list

    @property
    def content(self):
        """
        :return:
        """
        if self._content:
            return self._content
        self._content = self.connect_to_vcenter.RetrieveContent()
        return self._content

    @property
    def hosts_port_groups(self):
        """
        :return: A dict of hosts and their port groups
        :rtype: dict
        """
        if self._hosts_port_groups:
            return self._hosts_port_groups
        self._hosts_port_groups = {}
        for host in self.hosts:
            pgs = host.config.network.portgroup
            self._hosts_port_groups[host] = pgs
        return self._hosts_port_groups

    @property
    def vms(self):
        """
        :return:
        :rtype: list
        """
        if self._vms:
            return self._vms
        vm_view = self.content.viewManager.CreateContainerView(
            self.content.rootFolder,
            [vim.VirtualMachine],
            True,
        )
        self._vms = [vm for vm in vm_view.view]
        vm_view.Destroy()
        return self._vms

    def print_vm_info(self, vm):
        """
        Collect the VM's name and the list of nics
        :param vm:
        :return:
        :rtype: dict
        """
        nics = self.get_vm_nics(vm)
        vminfo = {
            'vmName': vm.name,
            'nics': nics,
        }
        return vminfo

    @property
    def hosts_all_data(self):
        """
        :return:
        :rtype: list
        """
        host_list = []
        for host_id in self.hosts_port_groups:
            entry = {
                host_id.name: []
            }
            for vm in self.vms:
                vcenter_vm_info = self.print_vm_info(vm)
                n_name = vcenter_vm_info['vmName']
                entry[host_id.name].append({n_name: vcenter_vm_info['nics']})
            host_list.append(entry)
        return host_list

    @property
    def hiera_contrail_settings(self):
        return self.generic.hiera_lookup('contrail', 'hash')

    def main(self):

        vcenter_dvswitch = self.hiera_contrail_settings['dvs_internal']
        vcenter_dvswitch_pg = vcenter_dvswitch + "-PG"
        contrail_vm_data = {}
        contrail_vm_list = []
        for data in self.hosts_all_data:
            for host, vms in data.iteritems():
                self.generic.debug('The vms information for host', host, '\n', yaml.dump(vms))
                for vm in vms:
                    self.generic.debug(yaml.dump(vm))
                    for vm_name, interfaces_list in vm.iteritems():
                        self.generic.debug('The interface config for vm: ', vm_name, '\n', yaml.dump(interfaces_list))
                        for interface in interfaces_list:
                            self.generic.debug('Interface configuration', yaml.dump(interface))
                            if interface['vSwitch'] == vcenter_dvswitch and \
                                            interface['portGroup'] == vcenter_dvswitch_pg:
                                contrail_vm_list.append(interface['macAddress'])
                                contrail_vm_data[host] = contrail_vm_list
        host_to_mac_binding = contrail_vm_data

        print(yaml.dump({'contrail_host_to_mac_binding': host_to_mac_binding}, explicit_start=True, default_flow_style=False))


if __name__ == '__main__':
    generic_object = Generic()
    generic_object.main()